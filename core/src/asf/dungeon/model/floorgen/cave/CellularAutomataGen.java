package asf.dungeon.model.floorgen.cave;

import asf.dungeon.model.Dungeon;
import asf.dungeon.model.FloorMap;
import asf.dungeon.model.FloorType;
import asf.dungeon.model.Tile;
import asf.dungeon.model.floorgen.FloorMapGenerator;
import asf.dungeon.model.floorgen.UtFloorGen;
import asf.dungeon.utility.OpenSimplexNoise;

/**
 *
 * creates a floor generated by simplex noise, then goes
 * through a specified number of generations to smooth out its features
 * (either make the floor slightly more open, or increase walls and curveyness)
 *
 * Created by Danny on 11/4/2014.
 */
public class CellularAutomataGen implements FloorMapGenerator {


        private int minFloorWidth = 45;
        private int maxFloorWidth = 60;
        private int minFloorHeight = 40;
        private int maxFloorHeight = 65;

        private double chanceToStartAlive = 0.2d;
        private double featureSize = 4d;
        private int numberOfGenerations = 2; // the more generations, the more smooth and open the floor becomes
        private int wallLimit = 4; // higher number means more floors  [0,9]
        private int floorLimit = 4; // lower number means more walls [4,8].

        private int maxCrates = 10;
        private int cratePlacementLimit = 5; // lower number more crates [0-5]


        @Override
        public FloorMap generate(Dungeon dungeon, FloorType floorType, int floorIndex) {
                numberOfGenerations = 0;
                wallLimit = 0;
                int floorWidth = dungeon.rand.range(minFloorWidth, maxFloorWidth);
                int floorHeight = dungeon.rand.range(minFloorHeight, maxFloorHeight);

                Tile[][] tiles = new Tile[floorWidth][floorHeight];

                OpenSimplexNoise noise = new OpenSimplexNoise(dungeon.rand.random.nextLong());

                for (int x = 0; x < tiles.length; x++){
                        for (int y = 0; y < tiles[0].length; y++){
                                if(noise.eval(x/featureSize , y/featureSize) > chanceToStartAlive){
                                        tiles[x][y] = Tile.makeWall();
                                }else{
                                        tiles[x][y] = Tile.makeFloor();
                                }
                        }
                }

                for (int k = 0; k < numberOfGenerations; k++){
                        generate(tiles);
                }

                UtFloorGen.ensureEdgesAreWalls(tiles);
                UtFloorGen.floodFillSmallerAreas(tiles);

                FloorMap floorMap = new FloorMap(floorType, floorIndex, tiles);
                UtFloorGen.placeUpStairs(dungeon, floorMap);
                UtFloorGen.placeDownStairs(dungeon, floorMap);
                UtFloorGen.spawnCharacters(dungeon, floorMap);
                UtFloorGen.spawnRandomCrates(dungeon, floorMap, maxCrates, cratePlacementLimit);
                return floorMap;
        }


        private void generate(Tile[][] tiles){

                for (int x = 0; x < tiles.length; x++){
                        for (int y = 0; y < tiles[0].length; y++){
                                evolveWalls(tiles, x, y);
                        }
                }
        }



        private void evolveWalls(Tile[][] tiles, int x, int y){
                int numWalls = UtFloorGen.countWalls(tiles, x, y);

                if(UtFloorGen.isWall(tiles, x, y)) {
                        if (wallLimit > numWalls) tiles[x][y] = Tile.makeFloor();
                }else {
                        if (floorLimit < numWalls) tiles[x][y] = Tile.makeWall();
                }

        }





}
